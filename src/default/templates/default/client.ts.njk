{% block header %}
/**
 * This file is automatically generated by the `@indirectus/cli` package.
 * Follow the package's instruction to update this file with the latest schema.
 */
{% endblock %}

{% block imports %}
import type * as Directus from "@directus/sdk";

import * as DirectusSDK from "@directus/sdk";

import { ApplyQueryFields } from './types/ApplyQueryFields';

import * as SystemBinding from './bindings/system-binding'
import * as ItemBinding from './bindings/item-binding'
{{ addons.imports | safe }}

type DirectusSDK = typeof DirectusSDK;

{% endblock %}

/*
declare module "@directus/sdk" {
  type DirectusAccess<Schema = any> = Directus.MergeCoreCollection<
    Schema,
    "directus_access", {
      id: string;
    }
  >;

  type DirectusPolicies<Schema = any> = Directus.MergeCoreCollection<
    Schema,
    "directus_policies", {
      id: string;
    }
  >;
}
*/

export namespace Types {
{% block types %}
  // Internal
  export type Nullable<T> = T | null;
  export type Optional<T> = Nullable<T>;
  export type UnknownType<T> = T | unknown;
  export type PrimaryKey<T> = T;

  // Numbers
  export type BigInteger = number;
  export type Decimal = number;
  export type Float = number;
  export type Integer = number;
  export type Number = number;

  // Buffers
  export type Binary = string;
  export type String = string;
  export type Text = string;

  // Date & Time
  export type Date = 'datetime';
  export type DateTime = 'datetime';

  // Geometry
  export namespace Geometry {
    export type LineString = any;
    export type MultiLineString = any;
    export type MultiPoint = any;
    export type MultiPolygon = any;
    export type Point = any;
    export type Polygon = any;
  }

  // Complex
  export type JSON = any;
  export type JSONSchema = any;

  // Others
  export type UUID = string;
  export type Boolean = boolean;
  export type Enum = string;

{% endblock %}
}

/**
 * All collection types.
 */
export namespace Collections {

{% for collection in registry.collections -%}
{% if collection.is_system %}

{%- set field_count = collection.fields | only_custom_fields | length -%}
  {% filter comment -%}
  The resolved {{ collection.name | to_collection_text }} collection type.
  {% endfilter %}
  export type {{ collection.name | to_collection_name }} = Directus.{{ collection.name | to_collection_name }}<System>;
{% endif %}
{% endfor %}

{% for collection in registry.collections -%}
{% if not collection.is_system %}
  /**
   * The {{ collection.name | space_case | lower_case }} collection.
   */
  export interface {{ collection.name | pascal_case }} {
{%- for field in collection.fields %}
{%- set type = field | to_ts_type -%}
{%- if type != 'never' %}
  {{ field.name | to_ts_identifier }}: {{ type }};
{%- endif -%}
{%- endfor %}
  }
{% endif %}
{% endfor %}
}

/**
 * All collection types.
 */
export type CollectionsType = {

{% for collection in registry.collections -%}
{% set suffix = "" if collection.is_singleton else "[]" %}
{% if collection.is_system %}

{%- set field_count = collection.fields | only_custom_fields | length -%}
  {% filter comment -%}
  The resolved {{ collection.name | to_collection_text }} collection type.
  {% endfilter %}
  {{ collection.name }} : Collections.{{ collection.name | to_collection_name }}{{ suffix }};
{% endif %}

{% if not collection.is_system %}
  /**
   * The {{ collection.name | space_case | lower_case }} collection.
   */
   {{ collection.name }} : Collections.{{ collection.name | pascal_case }}{{ suffix }};
{% endif %}
{% endfor %}
}

/**
 * System schema extensions.
 */

export interface System {

{% for collection in registry.collections -%}
{% if collection.is_system %}

  {% filter comment -%}
  The definition for the {{ collection.name | to_collection_text }} system collection.
  {% endfilter %}
  {{ collection.name }}: {
    {%- for field in collection.fields | only_custom_fields %}
      {%- set type = field | to_ts_type -%}
      {%- if type != 'never' %}
        {{ field.name | to_ts_identifier }}: {{ type }};
      {%- endif -%}
    {%- endfor %}
  }{{ "" if collection.is_singleton else "[]" }};

{% endif %}
{% endfor %}

}

/**
 * Schema definition.
 */
export interface Schema extends System {
{% for collection in registry.collections -%}
  {% if not collection.is_system %}
  {% set suffix = "" if collection.is_singleton else "[]" %}
  /**
   * The {{ collection.name | to_collection_text }} collection.
   */
  {{ collection.name | to_ts_identifier }}: Collections.{{ collection.name | pascal_case }}{{ suffix }};
  {% endif %}
{% endfor %}
}

/**
 * The Directus Client.
 */

export type DirectusRestCommands<T extends Record<any, any>> = keyof {
  [K in keyof T as T[K] extends (
    ...any: any[]
  ) => Directus.RestCommand<any, any>
    ? K
    : never]: K;
};

export type TypedClient = {
{%- for collection in registry.collections | filter_untype_system_collections %}

{% set collectionName = collection.name | to_collection_name %}
{% set collectionType = ["Collections.", collection.name | to_collection_name] | join %}
{% set genericQuery = ["const Query extends Directus.Query<CollectionsType, ", collectionType, ">"] | join %}
{% set applyType  = ["ApplyQueryFields<CollectionsType, ", collectionType, ", Query['fields']>"] | join %}

{% if collection.is_system %}

{% if not collection.is_singleton %}
  /**
   * Manages multiple items from the {{ collection.name.raw | to_collection_name }} collection.
   */
  {{ collection.name | to_collection_name | pluralize | to_collection_string  }}: SystemBinding.{{ collectionName }}Items;

  /**
   * Manages individual items from the {{ collection.name.raw | to_collection_name }} collection.
   */
  {{ collection.name | to_collection_name | singularize | to_collection_string  }}: SystemBinding.{{ collectionName }}Item;
{% else %}

  /**
   * Manage the only {{ collection.name.raw | singularize | to_collection_name }} instance available.
   */
  {{ collection.name | to_collection_name | to_collection_string  }}: SystemBinding.{{ collectionName }}Singleton;
  
  {% endif %}

{% else %}

{% if not collection.is_singleton %}
  /**
   * Manages multiple items from the {{ collection.name.raw | to_collection_name }} collection.
   */
  {{ collection.name | to_collection_name | pluralize | to_collection_string  }}: ItemBinding.{{ collectionName }}Items;

  /**
   * Manages individual items from the {{ collection.name.raw | to_collection_name }} collection.
   */
  {{ collection.name | to_collection_name | singularize | to_collection_string  }}: ItemBinding.{{ collectionName }}Item;
{% else %}

  /**
   * Manage the only {{ collection.name.raw | singularize | to_collection_name }} instance available.
   */
  {{ collection.name | to_collection_name | to_collection_string  }}: ItemBinding.{{ collectionName }}Singleton;
  
  {% endif %}

{% endif %}

{%- endfor %}

{{ addons.TypedClient | safe }}
} & {
  [K in keyof SystemBinding.Requests]: SystemBinding.Requests[K];
};

type ExcludedDirectusCommands = "withOptions" | "withToken" | "withSearch";

/**
 * This is almost a sanity check for protecting against breaking changes in the SDK.
 * If this is erroring for you, the SDK probably changed and there's an update needed.
 */

const excludedDirectusCommands: {
  [K in keyof Omit<
    DirectusSDK,
    Exclude<keyof DirectusCommands, ExcludedDirectusCommands>
  >]: true;
} = {
  ["auth"]: true,
  ["authentication"]: true,
  ["createDirectus"]: true,
  ["rest"]: true,
  ["formatFields"]: true,
  ["generateUid"]: true,
  ["getAuthEndpoint"]: true,
  ["graphql"]: true,
  ["memoryStorage"]: true,
  ["messageCallback"]: true,
  ["pong"]: true,
  ["queryToParams"]: true,
  ["realtime"]: true,
  ["sleep"]: true,
  ["staticToken"]: true,
  ["throwIfCoreCollection"]: true,
  ["throwIfEmpty"]: true,
  ["withOptions"]: true,
  ["withToken"]: true,
  ["withSearch"]: true,
} as const;

export type _InjectSchemaSystemTypes<T, Schema>
  = T extends Directus.Query<any, infer C> ? Directus.Query<Schema, C>
{% for collection in registry.collections -%}
{% if collection.is_system %}
  : T extends Directus.{{ collection.name | to_collection_name }}<any> ? Directus.{{ collection.name | to_collection_name }}<Schema>
{% endif %}
{% endfor %}
  : T extends Directus.DirectusUser<any> ? Directus.DirectusUser<Schema>
  : T;

export type InjectSchemaSystemTypes<T, Schema>
  = T extends Partial<infer Nested> ? Partial<_InjectSchemaSystemTypes<Nested, Schema>>
  : _InjectSchemaSystemTypes<T, Schema>
  ;

export type InjectSchema<T, Schema>
  = T extends [] ? []
  : T extends [infer Param] ? [InjectSchema<Param, Schema>]
  : T extends [infer Param, ...infer Rest] ? [InjectSchema<Param, Schema>, ...InjectSchema<Rest, Schema>]
  : InjectSchemaSystemTypes<T, Schema>;

export type DirectusCommands = {
  [K in DirectusRestCommands<DirectusSDK>]: (
    ...args: InjectSchema<Parameters<DirectusSDK[K]>, Schema>
  ) => Promise<
    ReturnType<DirectusSDK[K]> extends Directus.RestCommand<infer Output, any>
      ? Output
      : unknown
  >;
}

function isDirectusRestClient<Schema>(
  client: DirectusSDK.DirectusClient<Schema>,
): client is DirectusSDK.DirectusClient<Schema> &
  DirectusSDK.RestClient<Schema> {
  return client && "request" in client;
}

export const schema = () => {
  return <Schema>(client: Directus.DirectusClient<Schema>): TypedClient => {

    if (!isDirectusRestClient(client)) {
      throw new Error("Directus client must have the REST plugin enabled.");
    }

    return Object.fromEntries([
      ...Object.entries(new SystemBinding.Requests(client as any)),

{% for collection in registry.collections | filter_untype_system_collections %}
{% if collection.is_system %}

{% if not collection.is_singleton %}
      [{{ collection.name | to_collection_name | pluralize | to_collection_string }}, new SystemBinding.{{ collection.name | to_collection_name }}Items(client as any)],
      [{{ collection.name | to_collection_name | singularize | to_collection_string }}, new SystemBinding.{{ collection.name | to_collection_name }}Item(client as any)],
{% else %}
      [{{ collection.name | to_collection_name | to_collection_string }}, new SystemBinding.{{ collection.name | to_collection_name }}Singleton(client as any)],
{% endif %}

{% else %}

{% if not collection.is_singleton %}
      [{{ collection.name | to_collection_name | pluralize | to_collection_string }}, new ItemBinding.{{ collection.name | to_collection_name }}Items(client as any)],
      [{{ collection.name | to_collection_name | singularize | to_collection_string }}, new ItemBinding.{{ collection.name | to_collection_name }}Item(client as any)],
{% else %}
      [{{ collection.name | to_collection_name | to_collection_string }}, new ItemBinding.{{ collection.name | to_collection_name }}Singleton(client as any)],
{% endif %}
{% endif %}
{% endfor %}

{{ addons.schema | safe }}

    ]);

  };
}

export interface BindableClient {
  with: <
    Client extends DirectusSDK.DirectusClient<any>,
    Extension extends object,
  >(
    createExtension: (client: Client) => Extension,
  ) => this & Extension;
}

export const bindings = () => {
  return <Schema, Client extends DirectusSDK.DirectusClient<Schema>>(
    client: Client,
  ): BindableClient => {
    return {
      with(createExtension: any) {
        const extension = createExtension(this);
        const extensions = Object.entries(
          extension,
        ).reduce<PropertyDescriptorMap>((properties, [name, value]) => {
          return {
            ...properties,
            [name]: {
              value,
              configurable: true,
              writable: true,
              enumerable: true,
            },
          };
        }, {});

        Object.defineProperties(this, extensions);

        return this;
      },
    } as any;
  };
};

export function createDirectusWithTypes(
  url: string,
): Directus.DirectusClient<Schema> & Directus.RestClient<Schema> & TypedClient {
  return DirectusSDK.createDirectus<Schema>(url)
    .with(bindings())
    .with(DirectusSDK.rest())
    .with(schema());
}

export const createTypedClient = createDirectusWithTypes;
